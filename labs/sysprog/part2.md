# Partie 2: Compilation, debug et gestionnaire de signaux


## Exercice 1 : GDB et fichier core

Une fois le simulateur GPS compilé, le lancer grâce au script *gps/run.sh* :

````
$ sh run.sh
PTTY: /dev/pts/X
````

**Question 1** : Que se passe-t-il au bout de quelques secondes? Qu'en déduisez vous?

Le processus s'arrête et sort en *Segmentation Fault*. Une erreur a dû se produire lors du déroulement du processus.

**Question 2** : Quel signal a reçu le processus pour se terminer ainsi? Comment
                vérifiez vous le numéro du signal reçu?

Voici la liste des commandes lancées ainsi que les retours en lignes de commande :

````
~/embsys/labs/sysprog/gps$ sh run.sh
PTTY: /dev/pts/2
Segmentation fault (core dumped)
~/embsys/labs/sysprog/gps$ echo $?
139
~/embsys/labs/sysprog/gps$ kill -l 11               
SEGV
````
Le signal reçu est un SEGV soit un message de Segmentation Fault.



Lors d'une terminaison anormale, un fichier *core* peut être généré. Par défaut,
la génération d'un fichier core est généralement désactivée :

````
$ ulimit -c
0
````

Ici la commande renvoie grâce au paramètre *-c* la taille du fichier core à
générer. La taille étant 0, aucun fichier n'est créé. Pour y remédier :

````
$ ulimit -c unlimited
$ ulimit -c
unlimited
````

Relancez le simulateur GPS. Suite au crash, un fichier core doit être généré
dans le répertoire courant.

Nous allons ici utiliser GDB pour analyser le dump mémoire afin de trouver
l'origine de l'erreur. GDB est un outils très complet fournissant de
nombreuses commandes.

Pour lancer GDB et analyser un fichier core :

````
$ gdb ./bin/gps core
````

Ensuite, dans le prompt GDB, utilisez la commande *bt* (pour *backtrace*) afin
de savoir comment votre programme en est arrivé là (image de la pile).

**Question 3** : Grâce à GDB et au fichier *core* généré, analysez la source du
                 problème du binaire *gps*. Quelle partie du code est fausse?
                 Pourquoi?

Résultats fournis par gdb :

````
~/embsys/labs/sysprog/gps$ gdb . core
...
[New LWP 3801]
Core was generated by `/home/ganlan/embsys/labs/sysprog/gps/bin/gps'.
Program terminated with signal SIGSEGV, Segmentation fault.
#0  0x00007fb2b8f3e5a1 in ?? ()
(gdb)
````

Il manque les symboles pour pouvoir déchiffrer le message d'erreur. D'où l'apparition des "??" à la fin du message de gdb.



GDB peut être aussi lancé de manière interactive :

````
$ gdb ./bin/gps
````

Une fois dans le prompt, il faut lancer la commande *r* (comme *run*) et *bt*
pour récupérer la backtrace.

````
(gdb) bt
#0  __strlen_avx2 () at ../sysdeps/x86_64/multiarch/strlen-avx2.S:62
#1  0x00007fb2b8e309d2 in _IO_puts (str=0x0) at ioputs.c:35
#2  0x00007fb2b91a1aab in knot_to_kmh_str (not=5.51000023, size=6,
    format=0x7fb2b91a1f6f "%05.1f", kmh_str=0x7ffcf5661d82 "010.2")
    at nmea.c:23
#3  0x00007fb2b91a1ef6 in nmea_vtg (vtg=0x7ffcf5661dc0) at nmea.c:178
#4  0x00005609578d5c5c in write_vtg (fd=3) at gps.c:40
#5  0x00005609578d5ee1 in main () at gps.c:109
````

Il est aussi possible de placer des breakpoint sur une ligne de code, dans une
fonction, etc. Puis on peut avancer pas à pas avec *n* ou *s* (en fonction de
ce que l'on veut faire). Par exemple:

````
$ gdb ./bin/gps
$ break nmea.c:19
$ r
...
$ s
...
$ n
...
````

**Question 4** : Que se passe-t-il quand vous lancez GDB en mode interactif sur
                 le binaire *gps*?

````
~/embsys/labs/sysprog/gps$ gdb ./bin/gps
...
Reading symbols from ./bin/gps...done.        Lecture des symboles
(gdb) break nmea.c:19
No source file named nmea.c.
Make breakpoint pending on future shared library load? (y or [n]) y
Breakpoint 1 (nmea.c:19) pending.
(gdb) r
Starting program: /home/ganlan/embsys/labs/sysprog/gps/bin/gps
/home/ganlan/embsys/labs/sysprog/gps/bin/gps: error while loading shared libraries: libptmx.so: cannot open shared object file: No such file or directory
[Inferior 1 (process 2449) exited with code 0177]
````
On remarque à la première ligne que cette fois-ci les symboles ont bien été chargés, ce qui permet de traduire le message d'erreur. Le problème semble ici venir de l’absence de référence renvoyant vers la librairie *libptmx.so*.



Suite au problème repéré, allez dans le répertoire *gps/bin* et lancez la
commande suivante :

````
ldd ./gps
````

**Question 5** : À quoi sert la commande *ldd*? Quelle information
                supplémentaire cela vous apporte-t-il?

*ldd* est une commande permettant d'afficher l'ensemble des librairies partagées que nécessite un programme afin de pouvoir fonctionner. Cette commande appliquée au programme *gps* renvoie :

````
~/embsys/labs/sysprog/gps/bin$ ldd ./gps
	linux-vdso.so.1 (0x00007ffd2509c000)
	libptmx.so => not found
	libnmea.so => not found
	libc.so.6 => /lib/x86_64-linux-gnu/libc.so.6 (0x00007f6a3edf4000)
	/lib64/ld-linux-x86-64.so.2 (0x00007f6a3f3e8000)
````

On constate que les librairies *libptx.so* et *libnmea.so* sont bien requises pour l'exécution du binaire *gps* et qu'elles n'ont pas été trouvées par gcc.



**Question 6** : Comment résoudre ce problème en tant qu'utilisateur? N'hésitez
                 pas à regarder le fichier *gps/run.sh*.


Quand on lance l’exécutable directement, les librairies partagées manquantes ne
sont pas reconnues :
````
~/embsys/labs/sysprog/gps$ ./bin/gps
./bin/gps: error while loading shared libraries: libptmx.so: cannot open shared object file: No such file or directory
````
Quand on lance le run.sh, le programme se lance mais finit par planter en core dump.
Le fait que les librairies ne soient pas manquantes est due à la détection du dossier des librairies faite avec le *"export"* de la variable d'environnement *LD_LIBRARY_PATH* dans le run.sh. Pour régler le problème d'import des librairies, une solution serait de mettre le *"export"* dans le bashrc puis de le sourcer dans le terminal en cours.



Relancez *ldd* puis GDB pour vérifier que votre solution a porté ses fruits.

````
~/embsys/labs/sysprog/gps/bin$ ldd gps
	linux-vdso.so.1 (0x00007fff087be000)
	libptmx.so => /home/ganlan/embsys/labs/sysprog/gps/lib/libptmx.so (0x00007fd77f1c4000)
	libnmea.so => /home/ganlan/embsys/labs/sysprog/gps/lib/libnmea.so (0x00007fd77efc1000)
	libc.so.6 => /lib/x86_64-linux-gnu/libc.so.6 (0x00007fd77ebd0000)
	libm.so.6 => /lib/x86_64-linux-gnu/libm.so.6 (0x00007fd77e832000)
	/lib64/ld-linux-x86-64.so.2 (0x00007fd77f5c9000)
````
Les librairies ont bien été trouvées par gcc.


**Question 7** : Quelle est la différence entre les commandes *s* et *n* dans
                 le prompt gdb suite à un breakpoint?

````
~/embsys/labs/sysprog/gps/bin$ gdb gps
...
Reading symbols from gps...done.
(gdb) break nmea.c:19
No source file named nmea.c.
Make breakpoint pending on future shared library load? (y or [n]) y
Breakpoint 1 (nmea.c:19) pending.
(gdb) r
Starting program: /home/ganlan/embsys/labs/sysprog/gps/bin/gps
PTTY: /dev/pts/2

Breakpoint 1, knot_to_kmh_str (not=5.5, size=6,
   format=0x7ffff79d0f6f "%05.1f", kmh_str=0x7fffffffdaa2 "010.2")
   at nmea.c:20
20	    iteration++;
(gdb) s
21	    if (iteration == 2)
(gdb) s
27	    return kmh;
(gdb) s
28	}
(gdb) s
nmea_vtg (vtg=0x7fffffffdae0) at nmea.c:179
179	    memcpy(&vtg->frame[29], speed_kmh_str, NMEA_SPEED_SIZE);
(gdb) n
182	    vtg->frame[34] = NMEA_SEPARATOR;
(gdb) n
185	    vtg->frame[35] = 'K';
(gdb) n
187	    return 0;
(gdb) n
188	}
````

Le fichier se lance bien, la détection des librairies partagées a réussi.
Le débugger commence au breakpoint qui lui a été fourni. Après avoir lancé le débugger
("r"), on peut avancer par ligne ("s", step) ou par élément important ("n", next). Dans ce dernier cas, il exécute les appels de fonction sans les afficher.



Il existe aussi une version de GDB pour déboguer à distance. Il y
a alors un GDBServer tournant sur la cible où le programme à déboguer est
exécuté. Ensuite, un client GDB tourne sur la machine servant à déboguer
et communique avec le serveur grâce au réseau.

**Question 8** : Dans quel contexte ce type d'outils peut être intéressant?

Dans le cas d'erreurs à débugger à distance, sans avoir d'interface graphique
sur la machine à déboguer par exemple.



### À retenir

  * l'utilité de *ulimit* et comment déclencher la génération d'un fichier core
  * à quoi sert *GDB* et comment l'utiliser
  * l'utilité de *ldd*
  * pourquoi, quand et comment utiliser la variable d'environnement
    *LD_LIBRARY_PATH*




## Exercice 2 : LD_PRELOAD et sigaction

Maintenant que le problème est identifié, nous allons le résoudre. Cependant,
nous partons du principe que le code source du simulateur **NE DOIT PAS ÊTRE
MODIFIÉ**. Pour corriger le problème, nous allons utiliser la variable
d'environnement *LD_PRELOAD*. Cette variable permet de *hooker* (comprendre
*usurper*) certaines fonctions d'une application.

Utilisation :

````
LD_PRELOAD=libhook.so ./bin/gps
````

En faisant ainsi, le binaire cherchera en priorité les fonctions dont il
a besoin dans *libhook.so*! Pour que cela fonctionne, il faut que les fonctions
définies dans libhook aient exactement le même prototype.

Pour les questions suivantes, allez dans le répertoire de travail
*ld_preload*. Vous devrez travailler sur trois fichiers:

  * hook.c
  * Makefile
  * run.sh

**Question 1** : Implémentez dans le fichier hook.c la fonction à l'origine du
                 problème repéré au sein du simulateur GPS mais cette fois-çi
                 sans erreur.

J'ai modifié la fonction *hook.c* de la manière suivante :
````
int knot_to_kmh_str(float not, size_t size, char * format, char * kmh_str)
{
    float kmh = KNOT_TO_KMH * not;
    snprintf(kmh_str, size, format, kmh);
    printf("Hooked you!\n");

    return kmh;
}
````



**Question 2** : Éditez le Makefile pour compiler *hook.c* sous la forme d'une
                 librairie partagée nommée *libhook.so* (s'inspirer de
                 *gps/src/lib/ptmx/Makefile*). Testez la compilation.

Le make *all* modifié :
````
all: hook
	$(GCC) -g -c -fPIC hook.c -o hook.o
	$(GCC) -g -shared -Wl,-soname,$(SONAME) -o $(SONAME) hook.o
````



**Question 3** : Éditez le fichier *run.sh* pour utiliser LD_PRELOAD au moment
                 de lancer le simulateur et ainsi hooker le binaire avec la
                 librairie libhook.so. Exécutez run.sh : le simulateur ne doit
                 plus partir en segfault.

Retour de la commande :
````
~/embsys/labs/sysprog/ld_preload$ sh run.sh
PTTY: /dev/pts/2
Hooked you!
Hooked you!
Hooked you!
````
La fonction originale a bel et bien été remplacée par notre nouvelle fonction.



Nous avons ici hooké une fonction définie dans une librairie "utilisateur". On
peut réaliser la même opération sur les librairies systèmes. Par exemple, le
simulateur GPS utilise la fonction *printf* dès son lancement.

**Question 4** : Utilisez le *man* pour déterminer le prototype de la fonction
                 *printf* (expliquez comment vous utilisez *man* dans ce cas et
                 pourquoi). Comment est appelé ce type de fonction?

A l'aide de la commande *man man*, on apprend que les commandes sont classées dans le manuel selon différentes "pages" :

````
The table below shows the section numbers of the manual followed by the
types of pages they contain.

1   Executable programs or shell commands
2   System calls (functions provided by the kernel)
3   Library calls (functions within program libraries)
4   Special files (usually found in /dev)
5   File formats and conventions eg /etc/passwd
6   Games
7   Miscellaneous  (including  macro  packages  and  conventions), e.g.
    man(7), groff(7)
8   System administration commands (usually only for root)
9   Kernel routines [Non standard]
````

Ainsi, pour récupérer les informations concernant la fonction *printf*, il faudra rechercher *man 3 printf* afin de spécifier que nous cherchons la fonction des librairies standards C. On apprend que *printf* appartient à la librairie *stdio.h* et son prototype est :
````
int printf(const char *format, ...);
````
Ou format est un tableau de caractères possédant éventuellement des flags qui sont remplacés par les éléments suivants dans le tableau de caractères.



**Question 5** : Analysez *gps/src/bin/gps/gps.c* et repérez où se trouve le
                 gestionnaires de signaux. Décrivez les fonctions utilisées
                 ainsi que les signaux gérés.
````
// signals handler
struct sigaction action;
action.sa_handler = signals_handler;
sigemptyset(& (action.sa_mask));
action.sa_flags = 0;
sigaction(SIGINT, & action, NULL);
````
Dans ce gestionnaire de signaux, c'est l'utilitaire *sigaction* qui est utilisé et seul le CTRL-C semble pris en compte (*SIGINT*).



**Question 6** : Hookez le simulateur pour que ce dernier ne puisse plus
                 être interrompu par le signal SIGINT (Ctrl-C) en
                 réimplémentant la fonction *printf* dans libhook.so. Pour
                 cela, utilisez la fonction *sigaction* pour mettre en place
                 un gestionnaire de signaux au sein même de la fonction
                 *printf*  réimplémentée.

**Question 7** : Comment faire pour interrompre le processus étant donné
                 que ce dernier ne répond plus au Ctrl-C? Citez deux méthodes.

**Question 8** : En regardant le fichier *gps/Makefile*, que pouvez-vous dire
                 de la règle *ok*? À quoi sert-elle et comment
                 fonctionne-t-elle?

### À retenir

  * comment utiliser le *man*
  * la mise en place d'un gestionnaire de signaux grâce à *sigaction*
  * l'utilité et le fonctionnement de *LD_PRELOAD*


## Exercice 3 : Terminal série (minicom)

Dans le cas d'une communication série avec du matériel, il est toujours
intéressant d'observer les trames. En effet, on peut par exemple comprendre un
protocole de communication grâce à de la rétro ingénierie. Pour cela, il existe
des programmes tel que *gtkterm*, *PuTTY*, *picocom* et bien d'autres. Lors de
ce TP, nous allons utiliser *minicom*.

**Question 1** : Grâce à l'aide en ligne de commande de *minicom* (option
                 *-h*), se connecter au port du simulateur GPS et observez les
                 trames passées.

**Question 2** : Naviguez dans l'aide de minicom (Ctrl-A Z) pour récupérer la
                 configuration du port de communication. Expliquez brièvement
                 la signification de ces paramètres.

**Question 3** : Utiliser minicom pour capturer un extrait de la
                 communication dans un fichier.
